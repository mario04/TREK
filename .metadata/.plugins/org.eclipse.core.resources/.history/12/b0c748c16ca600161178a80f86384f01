/*! ----------------------------------------------------------------------------

 *  @file    main.c

 *  @brief   RX using double buffering example code

 *

 *           This example keeps listening for any incoming frames, storing in a local buffer any frame received before going back to listening. This

 *           examples activates interrupt handling and the double buffering feature of the DW1000 (but automatic RX re-enabling is not supported).

 *           Frame processing and manual RX re-enabling are performed in the RX good frame callback.

 *

 * @attention

 *

 * Copyright 2015 (c) Decawave Ltd, Dublin, Ireland.

 *

 * All rights reserved.

 *

 * @author Decawave

 */

#include "deca_device_api.h"

#include "deca_regs.h"

#include "lcd.h"

#include "port.h"
#include "compiler.h"


#define STANDARD_FRAME_SIZE         127

//#define STANDARD_FRAME_SIZE         80



#define ADDR_BYTE_SIZE_L            (8)

#define ADDR_BYTE_SIZE_S            (2)



#define FRAME_CONTROL_BYTES         2

#define FRAME_SEQ_NUM_BYTES         1

#define FRAME_PANID                 2

#define FRAME_CRC					2

#define FRAME_SOURCE_ADDRESS_S        (ADDR_BYTE_SIZE_S)

#define FRAME_DEST_ADDRESS_S          (ADDR_BYTE_SIZE_S)

#define FRAME_SOURCE_ADDRESS_L        (ADDR_BYTE_SIZE_L)

#define FRAME_DEST_ADDRESS_L          (ADDR_BYTE_SIZE_L)

#define FRAME_CTRLP					(FRAME_CONTROL_BYTES + FRAME_SEQ_NUM_BYTES + FRAME_PANID) //5

#define FRAME_CRTL_AND_ADDRESS_L    (FRAME_DEST_ADDRESS_L + FRAME_SOURCE_ADDRESS_L + FRAME_CTRLP) //21 bytes for 64-bit addresses)

#define FRAME_CRTL_AND_ADDRESS_S    (FRAME_DEST_ADDRESS_S + FRAME_SOURCE_ADDRESS_S + FRAME_CTRLP) //9 bytes for 16-bit addresses)

#define FRAME_CRTL_AND_ADDRESS_LS	(FRAME_DEST_ADDRESS_L + FRAME_SOURCE_ADDRESS_S + FRAME_CTRLP) //15 bytes for 1 16-bit address and 1 64-bit address)

#define MAX_USER_PAYLOAD_STRING_LL     (STANDARD_FRAME_SIZE-FRAME_CRTL_AND_ADDRESS_L-TAG_FINAL_MSG_LEN-FRAME_CRC) //127 - 21 - 16 - 2 = 88

#define MAX_USER_PAYLOAD_STRING_SS     (STANDARD_FRAME_SIZE-FRAME_CRTL_AND_ADDRESS_S-TAG_FINAL_MSG_LEN-FRAME_CRC) //127 - 9 - 16 - 2 = 100

#define MAX_USER_PAYLOAD_STRING_LS     (STANDARD_FRAME_SIZE-FRAME_CRTL_AND_ADDRESS_LS-TAG_FINAL_MSG_LEN-FRAME_CRC) //127 - 15 - 16 - 2 = 94





/* Example application name and version to display on LCD screen. */

#define APP_NAME "RX DBL BUFF v1.0"

typedef struct
{
    uint8 function_code;
    uint8 rangeNum;
    float tagxpos;
    float tagypos;
    uint8 vresploc;
    int ltrange;
    int rangeTime;
    uint8 newReport;
    uint8 tagAddr;

}LOC_MSG;

/* Default communication configuration. We use here EVK1000's default mode (mode 3). */

static dwt_config_t config = {

    2,               /* Channel number. */

    DWT_PRF_16M,     /* Pulse repetition frequency. */

    DWT_PLEN_1024,   /* Preamble length. Used in TX only. */

    DWT_PAC32,       /* Preamble acquisition chunk size. Used in RX only. */

    4,               /* TX preamble code. Used in TX only. */

    4,               /* RX preamble code. Used in RX only. */

    1,               /* 0 to use standard SFD, 1 to use non-standard SFD. */

    DWT_BR_110K,     /* Data rate. */

    DWT_PHRMODE_STD, /* PHY header mode. */

    (1025 + 64 - 32) /* SFD timeout (preamble length + 1 + SFD length - PAC size). Used in RX only. */

};



/* Buffer to store received frame. See NOTE 1 below. */

#define FRAME_LEN_MAX 127

static uint8 rx_buffer[FRAME_LEN_MAX];



/* Declaration of static functions. */

static void rx_ok_cb(const dwt_cb_data_t *cb_data);

static void rx_err_cb(const dwt_cb_data_t *cb_data);



/**

 * Application entry point.

 */
LOC_MSG loc;
int main(void)

{
loc.newReport = FALSE;
    /* Start with board specific hardware init. */

    peripherals_init();



    /* Display application name on LCD. */

    lcd_display_str(APP_NAME);



    /* Install DW1000 IRQ handler. */

    port_set_deca_isr(dwt_isr);



    /* Reset and initialise DW1000. See NOTE 2 below.

     * For initialisation, DW1000 clocks must be temporarily set to crystal speed. After initialisation SPI rate can be increased for optimum

     * performance. */

    reset_DW1000(); /* Target specific drive of RSTn line into DW1000 low for a period. */

    spi_set_rate_low();

    if (dwt_initialise(DWT_LOADNONE) == DWT_ERROR)

    {

        lcd_display_str("INIT FAILED");

        while (1)

        { };

    }

    spi_set_rate_high();



    /* Configure DW1000. */

    dwt_configure(&config);



    /* Activate double buffering. */

    dwt_setdblrxbuffmode(1);



    /* Register RX call-back. */

    dwt_setcallbacks(NULL, &rx_ok_cb, NULL, &rx_err_cb);



    /* Enable wanted interrupts (RX good frames and RX errors). */

    dwt_setinterrupt(DWT_INT_RFCG | DWT_INT_RPHE | DWT_INT_RFCE | DWT_INT_RFSL | DWT_INT_SFDT, 1);



    /* Activate reception immediately. See NOTE 3 below. */

    dwt_rxenable(DWT_START_RX_IMMEDIATE);



    /* Loop forever receiving frames. See NOTE 4 below. */

    while (1)

    {
    	if(loc.newReport == TRUE){
    		lcd_display_str("HELLO");
    		while(1);
    	}


    };

}



/*! ------------------------------------------------------------------------------------------------------------------

 * @fn rx_ok_cb()

 *

 * @brief Callback to process RX good frame events

 *

 * @param  cb_data  callback data

 *

 * @return  none

 */

static void rx_ok_cb(const dwt_cb_data_t *cb_data)

{

	uint8 fcode_index  = 0;

	uint8 srcAddr_index = 0;

    /* Perform manual RX re-enabling. See NOTE 5 below. */

    dwt_rxenable(DWT_START_RX_IMMEDIATE | DWT_NO_SYNC_PTRS);



    /* TESTING BREAKPOINT LOCATION #1 */



    /* A frame has been received, copy it to our local buffer. See NOTE 6 below. */

    if (cb_data->datalength <= FRAME_LEN_MAX)

    {

        dwt_readrxdata(rx_buffer, cb_data->datalength, 0);

			fcode_index = FRAME_CRTL_AND_ADDRESS_S; //function code is in first byte after source address

			srcAddr_index = FRAME_CTRLP + ADDR_BYTE_SIZE_S;

			if(rx_buffer[fcode_index]==0x3B){
				loc.newReport = TRUE;
			}



   }



    /* TESTING BREAKPOINT LOCATION #2 */

}



/*! ------------------------------------------------------------------------------------------------------------------

 * @fn rx_err_cb()

 *

 * @brief Callback to process RX error events

 *

 * @param  cb_data  callback data

 *

 * @return  none

 */

static void rx_err_cb(const dwt_cb_data_t *cb_data)

{

    /* Re-activate reception immediately. */

    dwt_rxenable(DWT_START_RX_IMMEDIATE);



    /* TESTING BREAKPOINT LOCATION #3 */

}



/*****************************************************************************************************************************************************

 * NOTES:

 *

 * 1. In this example, maximum frame length is set to 127 bytes which is 802.15.4 UWB standard maximum frame length. DW1000 supports an extended

 *    frame length (up to 1023 bytes long) mode which is not used in this example.

 * 2. In this example, LDE microcode is not loaded upon calling dwt_initialise(). This will prevent the IC from generating an RX timestamp. If

 *    time-stamping is required, DWT_LOADUCODE parameter should be used. See two-way ranging examples (e.g. examples 5a/5b).

 * 3. Manual reception activation is performed here but DW1000 offers several features that can be used to handle more complex scenarios or to

 *    optimise system's overall performance (e.g. timeout after a given time, automatic re-enabling of reception in case of errors, etc.).

 * 4. There is nothing to do in the loop here as frame reception and RX re-enabling is handled by the callbacks. In a less trivial real-world

 *    application the RX data callback would generally signal the reception event to some background protocol layer to further process each RX frame.

 * 5. When using double buffering, RX can be re-enabled before reading all the frame data as this is precisely the purpose of having two buffers. All

 *    the registers needed to process the received frame are also double buffered with the exception of the Accumulator CIR memory and the LDE

 *    threshold (accessed when calling dwt_readdiagnostics). In an actual application where these values might be needed for any processing or

 *    diagnostics purpose, they would have to be read before RX re-enabling is performed so that they are not corrupted by a frame being received

 *    while they are being read. Typically, in this example, any such diagnostic data access would be done at the very beginning of the rx_ok_cb

 *    function.

 * 6. A real application might get an operating system (OS) buffer for this data reading and then pass the buffer onto a queue into the next layer

      of processing task via an appropriate OS call.

 * 7. The user is referred to DecaRanging ARM application (distributed with EVK1000 product) for additional practical example of usage, and to the

 *    DW1000 API Guide for more details on the DW1000 driver functions.

 ****************************************************************************************************************************************************/
